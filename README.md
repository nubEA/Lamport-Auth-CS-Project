# Lamport Authentication Protocol Demonstrator

This project is a desktop application developed in C++ using the Qt framework to demonstrate the Lamport one-time password (OTP) authentication scheme. It simulates a client-server interaction where a client (Bob) authenticates itself to a server (Alice) over multiple rounds using a one-way hash chain. The cryptographic functionalities are implemented using the Crypto++ library.

## What is Lamport Authentication?

The Lamport scheme is a one-time password (OTP) protocol designed to be secure against eavesdropping attacks. Unlike traditional passwords, an OTP is valid for only one login session or transaction. Even if an attacker intercepts a password, it cannot be reused for a future session (a defense against **replay attacks**).

The scheme is built upon the concept of a **one-way hash chain**.

### The Hash Chain

A one-way hash chain is generated by repeatedly applying a cryptographic hash function to a starting value, known as a seed.

Given a random seed $h\_0$ and a secure hash function $H(\\cdot)$, the chain is constructed as follows:

  - $h\_1 = H(h\_0)$
  - $h\_2 = H(h\_1)$
  - ...
  - $h\_n = H(h\_{n-1})$

Due to the **pre-image resistance** property of secure hash functions, it is computationally easy to compute $h\_n$ from $h\_0$, but infeasible to compute $h\_0$ from $h\_n$.

### Protocol Phases

The protocol operates in two main phases:

1.  **Setup Phase**:

      * **Bob (the Client)** generates a long hash chain of length $n$ starting from a secret random seed, $h\_0$.
      * He keeps the entire chain secret but securely transmits the final hash, $h\_n$, to **Alice (the Server)**. Alice stores this value.

2.  **Challenge-Response Phase**:
    This phase is repeated for each authentication attempt, for a maximum of $n-1$ times.

      * Alice wants to authenticate Bob. She maintains a counter $c$, initialized to 1. She sends the current value of $c$ as a challenge to Bob.
      * Bob receives the challenge $c$ and computes the response $r = h\_{n-c}$. He sends $r$ back to Alice.
      * Alice receives the response $r$. To verify it, she computes $H(r)$ and checks if it matches the hash value she currently has stored (for the first challenge, this is $h\_n$).
      * If $H(r) == h\_{n-(c-1)}$, the verification is successful. Alice then updates her stored hash to be $r$ and increments her counter for the next round. If the verification fails, the connection is terminated.

With each successful authentication, Alice's stored hash moves one step backward down the chain, from $h\_n$ to $h\_{n-1}$, then to $h\_{n-2}$, and so on, until it reaches $h\_1$.

-----

## Project Structure

The project is organized into a clean and modular structure to separate concerns like GUI, networking, authentication logic, and utilities.

```
.
├── CMakeLists.txt
├── include
│   ├── Client.hpp
│   ├── ConfigManager.hpp
│   ├── CryptoUtils.hpp
│   ├── LamportAuth.hpp
│   ├── MainWindow.hpp
│   └── Server.hpp
└── src
    ├── auth
    │   ├── CryptoUtils.cpp
    │   └── LamportAuth.cpp
    ├── gui
    │   ├── MainWindow.cpp
    │   └── mainwindow.ui
    ├── main.cpp
    ├── network
    │   ├── Client.cpp
    │   └── Server.cpp
    └── util
        └── ConfigManager.cpp
```

-----

## Core Components

  * `MainWindow`: Manages the application's GUI using Qt Widgets. It connects user actions (button clicks) to the underlying client/server logic.
  * `Server` (Alice): Implemented using `QTcpServer`. It listens for incoming connections, sends challenges periodically, and verifies the responses received from the client using the `LamportAuth` module.
  * `Client` (Bob): Implemented using `QTcpSocket`. It connects to the server, generates the initial hash chain, sends the final hash $h\_n$, and responds to challenges from the server.
  * `LamportAuth`: A class that encapsulates the core logic of the Lamport scheme. It is responsible for generating the hash chain and verifying OTPs.
  * `CryptoUtils`: A utility class that wraps the Crypto++ library to provide SHA-256 hashing, random seed generation, and hex encoding.
  * `ConfigManager`: A helper class that parses a `config.json` file to load network parameters like IP addresses, ports, and other settings.

-----

## How It Works

The application can be run in one of two modes: **Server (Alice)** or **Client (Bob)**.

1.  **Configuration**: Before running, create a `config.json` file in the build directory. This file contains the network settings for both parties.

2.  **Connection**:

      * One user launches the application and selects the **Server** radio button before clicking **Connect**. The application starts listening on the IP and port specified for Alice in the config file.
      * The second user launches the application, selects the **Client** radio button, and clicks **Connect**. The client attempts to connect to the server.

3.  **Initialization**:

      * Once a connection is established, the **Client (Bob)** automatically generates a secure random seed and computes the entire hash chain.
      * It immediately sends the final hash of the chain, $h\_n$, to the **Server (Alice)**.
      * The server receives and stores this hash. The log window will indicate that the initial hash has been received and it's ready for authentication.

4.  **Authentication Process**:

      * The **Server (Alice)** user clicks the **Start** button to begin the challenge-response cycles.
      * The server sends a challenge (an integer, starting at 1) to the client every second (or as configured in `sleepDuration`).
      * The client receives the challenge $c$ and sends back the corresponding pre-computed hash, $h\_{n-c}$.
      * The server hashes the received response and compares it to its stored hash value. If they match, the authentication is successful, the server updates its stored hash, and the process continues.
      * If verification fails at any point, the server terminates the connection.

5.  **Controls**:

      * **Stop**: The server user can click this at any time to halt the challenge-response process.
      * **Disconnect**: Either user can click this to terminate the TCP connection.

-----

## Prerequisites

To build and run this project, you need the following dependencies installed:

  * A C++17 compliant compiler (e.g., GCC, Clang, MSVC).
  * **CMake** (version 3.16 or later).
  * **Qt5 Framework** (Core, GUI, Widgets, Network modules).
  * **Crypto++ Library** (`libcryptopp-dev` on Debian/Ubuntu).
    
For Fedora: 
```bash
sudo dnf install -y gcc-c++ cmake make qt5-qtbase-devel cryptopp-devel qt5-qtwayland
```
-----

## Building and Running

1.  **Clone the repository**:

    ```bash
    git clone https://github.com/nubEA/Lamport-Auth-CS-Project.git
    cd lamport-auth-qt
    ```

2.  **Configure and build with CMake**:

    ```bash
    mkdir build && cd build
    cmake ..
    cmake --build .
    ```

3.  **Configure the application**:
    Create a `config.json` file inside the `build` directory. See the section below for details.

4.  **Run the application**:
    You need to run two instances of the application.

      * Open two separate terminals in the `build` directory.
      * Run `./LamportAuth` in each terminal.
      * In the first window, select the **Server** role and click **Connect**.
      * In the second window, select the **Client** role and click **Connect**.
      * Once connected, use the **Start** button in the server window to begin the authentication process.

-----

## Configuration

The application's behavior is controlled by a `config.json` file located in the same directory as the executable.

#### Example `config.json`:

```json
{
    "aliceIP": "127.0.0.1",
    "alicePort": 8080,
    "bobIP": "127.0.0.1",
    "bobPort": 8081,
    "sleepDuration": 1,
    "numberOfIterations": 100
}
```

  * `aliceIP`, `alicePort`: The IP address and port for the Server (Alice) to listen on.
  * `bobIP`, `bobPort`: Not used in this implementation but reserved for future extensions. The client connects to Alice's IP/port.
  * `sleepDuration`: The delay in seconds between each challenge sent by the server.
  * `numberOfIterations`: The length ($n$) of the hash chain to be generated.

## Team Members:
* Vardaan Pahwa (IIT2023249)
* Harshit Tatwedi (IIT2023215)
* Ashish Saraswat (IIT2023270)
* Pratham Jain (IIT2023248)
* Hare Krishna Pahri (IIT2023256)
